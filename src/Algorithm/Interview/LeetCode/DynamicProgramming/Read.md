# 动态规划问题的特征

- 首要是状态设计；然后是状态转移
- 首先可以切分为一个个子问题，每一个子问题都是一个最优解
- 可以用递归来解决
- 递归函数是一个 状态=子问题=子问题的解决方案
- 递归可以用记忆化搜索来优化


[动态规划与状态机](https://recomm.cnblogs.com/blogpost/11277064)


[股票问题](https://www.cnblogs.com/hanyuhuang/p/11083384.html)

# 动态规划分类

[动态规划 分类](http://cppblog.com/menjitianya/archive/2015/10/23/212084.html)

- 线性模型 opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] + 2*a[2] }
- 区间模型 d[i][j] = min{ d[i+1][j], d[i][j-1] } + 1
- 背包模型  f[i][v] = max{ f[i-1][v], f[i-1][v - Ci] +Wi } 
- 状态压缩模型
- 树状模型


# 栗子

## 小朋友过桥

- n个人
- 每次最多过2个
- 只有一个手电筒，每次过桥的两个人需要把手电筒带回来
- i号小朋友过桥的时间为T[i]
- 求最短过桥时间

# 动态规划总结

## 三要素

- 状态
- 选择（转移）
- base case

## 思路

> 动态规划一定是一个状态递推的过程

> 也就是当前的状态一定由，之前的状态地推而来。 也就是说 dp[i] 一定与i密切相关

> 所谓选择就是之前状态，到达当前状态的路径

> 题干所求不一定是，直接的动态规划结果； 可以考虑把 题干要求转化 为与 i相关 （与 i 相关 == 重叠子问题）
>然后 在 dp 空间里面求解


# 子序列

## 一维dp

> 在子数组array[0..i]中，以array[i]结尾的目标子序列（最长递增子序列）的长度是dp[i]。

```bash
int n = array.length;
int[] dp = new int[n];

for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}
```

## 二维dp

```bash
int n = arr.length;
int[][] dp = new dp[n][n];

for (int i = 0; i < n; i++) {
    for (int j = 1; j < n; j++) {
        if (arr[i] == arr[j]) 
            dp[i][j] = dp[i][j] + ...
        else
            dp[i][j] = 最值(...)
    }
}
```

> 涉及两个字符串/数组时: 在子数组arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列（最长公共子序列）长度为dp[i][j]。

>  只涉及一个字符串/数组时: 在子数组array[i..j]中，我们要求的子序列（最长回文子序列）的长度为dp[i][j]。